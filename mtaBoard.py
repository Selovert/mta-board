#!/usr/bin/env python
import time, datetime
import sys, os, subprocess
import pickle
import logging

from math import floor
from PIL import Image, ImageDraw, ImageFont
from traceback import format_exception

sys.path.append("/home/dietpi/Repos/mta-board/rpi-rgb-led-matrix/bindings/python")
from rgbmatrix import RGBMatrix, RGBMatrixOptions
# from RGBMatrixEmulator import RGBMatrix, RGBMatrixOptions

from mtaPuller import ArrivingTrain

# region --- initialise logging ---
logger = logging.getLogger(__name__)
handler = logging.StreamHandler(stream=sys.stdout)
logger.addHandler(handler)
fh = logging.FileHandler(f'{os.path.dirname(os.path.realpath(__file__))}/mta-board.log')
fh.setLevel(logging.WARNING)
logger.addHandler(fh)

def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    logger.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception
# endregion

class MatrixBoard():
    def __init__(self, *args, **kwargs):
        # Configuration for the matrix
        options = RGBMatrixOptions()
        options.rows = 32
        options.cols = 64
        options.brightness = 60
        options.chain_length = 1
        options.parallel = 1
        options.hardware_mapping = 'adafruit-hat-pwm'  # If you have an Adafruit HAT: 'adafruit-hat'
        options.gpio_slowdown = 3
        # options.pwm_lsb_nanoseconds = 130
        options.limit_refresh_rate_hz = 160
        options.show_refresh_rate = 0

        # EMLUTATOR SETTINGS
        options.pixel_style = 'circle'
        
        self.dir = os.path.dirname(os.path.realpath(__file__)) # directory of this file
        self.logo = Image.open(f'{self.dir}/assets/images/L_logo.png').convert('RGBA') # pull logo from the assets
        self.traincarImg = Image.open(f'{self.dir}/assets/images/traincar_tall.png').convert('RGBA')

        self.matrix = RGBMatrix(options = options) # init the matrix with its options
        
        self.running = False # start as not running
        self.runTime = 0
        self.i = 0 # number of updates that have been ticked

    def run(self):
        self.startTime = datetime.datetime.now()
        self.font = ImageFont.truetype(f'{self.dir}/assets/fonts/04B_03__.TTF', size=8)
        self.timeFont = ImageFont.truetype(f'{self.dir}/assets/fonts/luminator-4x6-dotmap.ttf', size=6, )

        self.canvas = self.matrix.CreateFrameCanvas()

        self.running = True # start things up
        while self.running:
            runTime:datetime.timedelta = datetime.datetime.now() - self.startTime # get runtime as timedelta
            self.runTime:float = runTime.seconds + runTime.microseconds * 10.0**-6 # convert runtime to sec
            self.image = Image.new('RGBA', (self.matrix.width, self.matrix.height)) # new PIL image to build on

            self.readArrivals() # update the train arrivals data from the pickle file
            

            if self.runTime < 5:
                self.showIP() # default to showing the IP for a few seconds since this is an otherwise-headless setup
            else:
                if self.arrivals:
                    self.showTrains()
                else:
                    self.showNoTrainMessage()


            self.canvas.Clear() # clear whatever's on the screen
            self.canvas.SetImage(self.image.convert('RGB'), 0, 0) # transfer the PIL image to the canvas

            self.i += 1 # increment the number of iterations run
            time.sleep(0.005) # the nominal fastest tick time
            self.canvas = self.matrix.SwapOnVSync(self.canvas) # pulls in the just-generated canvas on the next frame
    
    def showIP(self):
        """
        Show the machine's wifi IP on the screen
        """
        ip: str = subprocess.check_output(['ipconfig getifaddr en0'], encoding='UTF-8')
        ipBox = TextBox(text=ip, font=self.font, x=0, y=-1)
        ipBox.addToImage(self.image, (1,1))

    def readArrivals(self):
        """
        Pull the arrivals list from the pickle file generated by mtaPuller.py
        """
        try:
            with open(f'{self.dir}/mta-arrivals.cache', 'rb') as f:
                self.arrivals: list[ArrivingTrain] = pickle.load(f)
        except:
            return None

    def showTrains(self):
        """
        Process self.arrivals into info to show on the board.
        This method just adds to self.image with that info
        """

        for arrival in self.arrivals: # for each train coming
            y0 = 1 + 16 * self.arrivals.index(arrival) # second train gets everything 16px lower in y
            fill = '#FFEC8A' if arrival.stopsRemaining < 3 else None # special yellow text color if the train is IMMINENT

            self.image.paste(im=self.logo, box=(1,y0)) # plop in the L train logo
            nextStopBox = TextBox(text=arrival.nextStop, font=self.font, width=53, type='scrolling', i=int(self.runTime*15), fill=fill)
            nextStopBox.addToImage(self.image, (10,y0+1))

            # ------ Shows how many stops are left ------
            # stopsBox = TextBox(text=f'{arrival.stopsRemaining} stops', font=self.font, x=0, y=-1)
            # stopsBox.addToImage(self.image, (0,y0+1))

            # ------ Shows a bouncy train ------
            # trainImage = Image.new('RGBA', (21, 7))
            # trainPosIndex = int(self.runTime*8) % 16 # scoot cars at 16Hz
            # trainPositions = [-29, -13, 3, 19]
            # if arrival.trainMoving:
            #     trainPositions = [p+trainPosIndex for p in trainPositions]
            # for pos in trainPositions:
            #     y = 1 + floor(self.runTime*1)%2 # bounce the cars up and down at 1 Hz
            #     trainImage.paste(im=self.traincarImg, box=(pos, y))
            # self.image.paste(im=trainImage, box=(42, y0))

            # ------ Shows ETA with blinky colon ------
            # if floor(self.runTime/0.3)%2:
            #     colonBox = TextBox(text=':', font=self.timeFont, height=7)
            #     colonBox.addToImage(self.image, (10,y0+9))
            # etaMinBox = TextBox(text=f'{floor(arrival.timeUntil.seconds/60):02d}', font=self.timeFont, type='static')
            # self.draw.bitmap((0,y0+9), bitmap=etaMinBox.outputImage.convert('RGBA'))
            # etaSecBox = TextBox(text=f'{arrival.timeUntil.seconds % 60}', font=self.timeFont, type='static')
            # self.draw.bitmap((12,y0+9), bitmap=etaSecBox.outputImage.convert('RGBA'))
            # etaBox = TextBox(text=arrival.timeUntilStr, font=self.font, x=0, y=-1, type='static')
            
            if arrival.trainDelay: # if the particular train is delayed
                fill = '#FF3700' # make the  subsequent text red

            etaText = f'{floor(arrival.timeUntil.seconds/60)} min {arrival.timeUntil.seconds % 60} sec'
            etaBox = TextBox(text=etaText, font=self.font, fill=fill)
            etaBox.addToImage(self.image, (1,y0+9))

            if arrival.lineAlert: # if there's a general alert on the line like a change in service
                self.showLineAlert()

    def showLineAlert(self):
        """
        Draws an angry red line around the perimeter of the screen.
        This method just adds to self.image
        """
        ImageDraw.Draw(self.image).line(xy=((0,0),(63,0),(63,31),(0,31),(0,0)), fill='#FF3700', width=1)
    
    def showNoTrainMessage(self):
        """
        Puts a message on the screen to say there are no trains coming
        This method just adds to self.image
        """
        noTrainBox = TextBox(text='No trains :(', font=self.font, x=0, y=-1)
        noTrainBox.addToImage(self.draw, (9,13))
        

class TextBox:
    """
    Represents a text box that can be added to the board.
    self.outputImage and self.addToImage are the best ways to get the text

    Parameters:
        text (str): the text to show
        font (ImageFont.FreeTypeFont): your font of choice
        x (int): shift the font within the text box in x. Defaults to 0
        y (int): shift the font within the text box in y. Defaults to 0
        width (int): Optional argument to force the box width (good for scrolling text)
        height (int): Optional argument to force the box height (good for weird fonts)
        type (str): can be 'static', 'scrolling', or 'blinking'
        i (int): link this to something that ticks at the fequency you want animations to update at
    """
    def __init__(self,
                 text:str,
                 font:ImageFont.FreeTypeFont,
                 fill:str|None = None,
                 x:int=None,
                 y:int=None,
                 width:int=None,
                 height:int=None,
                 type:str='static',
                 i:int=0,
                 ):
        
        self.text = str(text)
        self.font = font
        self.type = type
        self.fill = fill
        self.i = i
        self.holdSteps = 40 # ticks to hold between scrolling

        boundingBox = self.font.getmask(self.text).getbbox()
        self.textWidth = boundingBox[2]
        self.textHeight = boundingBox[3]
        self.width = width if width else self.textWidth # default to the calculated width if no arg given
        self.height = height if height else self.textHeight # default to the calculated height if no arg given

        self.x = x if x else 0 # default to the zero offset if no arg given
        self.y = y if y else 0 # default to the zero offset if no arg given

        match font.font.family: # some defaults for fonts I know the offsets of
            case '04b03':
                self.y = y if y else -1 # default to the -1 offset if no arg given

        self.outputImage = Image.new('RGBA', (self.width, self.height)) # blank image to draw on
        self.outputDraw = ImageDraw.Draw(self.outputImage) # draw object to use for adding text

        match self.type:
            case 'scrolling':
                self.showScrollingText()
            case 'blinking':
                if int(self.i)%2: # show text every other tick
                    self.showStaticText()
            case _:
                self.showStaticText()

    def showStaticText(self):
        self.outputDraw.text((self.x, self.y), self.text, fill=self.fill, font=self.font)

    def showScrollingText(self):
        spacing = int(self.textHeight * 2) # this is a nice amount of spacing. I'm hardcoding it!
        scrollWidth = self.textWidth + spacing # width of the scrolling element with its spacing
        
        if self.textWidth < self.width: # if there's no point in scrolling because the whole text fits
            self.showStaticText() # just show the text
            return None

        positions = [-2*scrollWidth, -scrollWidth, 0] # create some instances that can scroll into the screen
        posAdjustment = self.i % (scrollWidth + self.holdSteps) # the amount to scoot each instance over by each time
        # the line above does a modulo of the scrollwidth because restarting after that many steps is seamless.
        # holdSteps just makes the scrolling hesitate so it's easier to read

        for pos in positions: # for each instance of the text
            if posAdjustment <= scrollWidth: # only shift the text for one unit of scrolling
                pos += posAdjustment # shift text to the right
            self.outputDraw.text((pos, self.y), self.text, fill=self.fill, font=self.font)
    
    def addToImage(self, imgObj:ImageDraw.ImageDraw, pos:tuple[int, int]):
        imgObj.paste(im=self.outputImage, box=pos) # plop the textbox image into the parent image at the given position
        

if __name__ == "__main__":
    board = MatrixBoard()
    while True:
        try:
            board.run()
        except Exception as ex:
            logging.error(''.join(format_exception(None, ex, ex.__traceback__)))
            continue